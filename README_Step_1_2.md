# Step 1.2 – Content Type Classification

This step processes the parsed metadata produced in Step 1.1, classifies each file into a content category, and exports the results for later organization work. The classification logic is fully data driven via `content_classification_config.json`, so you can adjust weights or categories without touching the script itself.

## Prerequisites

- PowerShell 7+
- `top50_parsed_data.json` generated by Step 1.1 in the same directory as the script, or a custom path supplied with `-InputFile`
- `content_classification_config.json` in the same directory (auto-created with defaults) or a custom config supplied with `-ConfigFile`

## Files

- `classify_content_types.ps1` – main PowerShell entry point
- `content_classification_config.json` – scoring rules, category priorities, and naming conventions
- `content_classification_results.json` – output report produced by the script

## Usage

```powershell
pwsh -NoProfile -File .\classify_content_types.ps1 [-InputFile <path>] [-ConfigFile <path>] [-NoPause]
```

### Common scenarios

- **Default run** – searches for `top50_parsed_data.json` and `content_classification_config.json` alongside the script:

  ```powershell
  pwsh -NoProfile -File .\classify_content_types.ps1 -NoPause
  ```

- **Alternative data source** – point to a different parsed-data file (relative or absolute path):

  ```powershell
  pwsh -NoProfile -File .\classify_content_types.ps1 -InputFile C:\exports\parsed_batch.json -NoPause
  ```

- **Custom rules** – use a different configuration bundle:

  ```powershell
  pwsh -NoProfile -File .\classify_content_types.ps1 -ConfigFile .\configs\festival_rules.json -NoPause
  ```

Omit `-NoPause` if you want the script to prompt before closing when run interactively.

## Configuration

`content_classification_config.json` describes how categories are scored.

- `CategoryPriority` determines the tie-break order when multiple categories earn the same score.
- Each `Categories.<Name>.Triggers` entry adds points when a file matches:
  - `Regex` – compiled against `FileName` (default) or `FullPath`
  - `Keyword` – case-insensitive match against the parsed keywords array
  - `Extension` – compare against the file extension (prefix with a dot)
- `NamingConvention` strings feed the recommendation section of the console output and the results JSON.

Duplicate category names in `CategoryPriority` are ignored; any category missing from the priority list is appended automatically.

## Output

- Console summary showing per-file classifications, totals, and top examples per category
- `content_classification_results.json` containing:
  - Generation timestamp
  - Counts of classified files and errors
  - The full breakdown of file metadata grouped by category
  - Naming convention recommendations
  - Absolute path to the configuration used for the run

## Customizing the Classifier

1. Duplicate or edit `content_classification_config.json`.
2. Adjust trigger `Score` weights, add/remove regex patterns, keywords, or extensions.
3. Update `CategoryPriority` if you add new categories or want different tie-break behaviour.
4. Re-run the script with the updated config (or pass `-ConfigFile` to keep multiple presets).

Tip: keep triggers relatively specific to avoid leaking noisy matches into unrelated categories. Use additional lower-weight clues (keywords, extensions) to reinforce the primary regex conditions.

## Troubleshooting

- **Missing input/config files** – verify the paths, or pass explicit `-InputFile` / `-ConfigFile` arguments.
- **Config parse errors** – ensure the JSON is valid. The script reports the failing pattern or section in the console.
- **Unexpected classifications** – inspect the scoring output by lowering trigger weights or adding new clues, then re-run.

## Next Step

With the categorized output available, proceed to Step 1.3 to design and apply naming conventions based on the recommendations produced here.
