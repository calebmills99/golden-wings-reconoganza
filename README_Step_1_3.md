# Step 1.3 – Naming Convention Design

This stage consumes the categorized file metadata from Step 1.2 and applies configurable naming rules to propose human-readable file names. The script keeps everything non-destructive: it emits a rename mapping report and highlights conflicts without touching the source files.

## Prerequisites

- PowerShell 7+
- `content_classification_results.json` generated by Step 1.2 (or pass a custom path with `-InputFile`)
- `naming_convention_config.json` providing the rule set (you can copy the repo default and adjust as needed)

## Files

- `design_naming_conventions.ps1` – rule-driven naming engine
- `naming_convention_config.json` – declarative rules, patterns, and global settings
- `rename_mappings.json` – output file describing every proposed rename

## Usage

```powershell
pwsh -NoProfile -File .\design_naming_conventions.ps1 [-InputFile <path>] [-ConfigFile <path>] [-PreviewOnly] [-NoPause]
```

### Examples

- **Standard preview** – use the default inputs and generate mappings without prompting at the end:

  ```powershell
  pwsh -NoProfile -File .\design_naming_conventions.ps1 -PreviewOnly -NoPause
  ```

- **Alternate classification bundle** – point to a different Step 1.2 output:

  ```powershell
  pwsh -NoProfile -File .\design_naming_conventions.ps1 -InputFile ..\exports\classification.json -PreviewOnly
  ```

- **Custom ruleset** – evaluate an alternative naming policy:

  ```powershell
  pwsh -NoProfile -File .\design_naming_conventions.ps1 -ConfigFile .\configs\festival_rules.json -PreviewOnly
  ```

`-PreviewOnly` keeps the behavior read-only (recommended for Step 1.3). Omit it only if a later version adds direct renaming.

## Configuration Schema

`naming_convention_config.json` is organized around `NamingRules` plus optional `GlobalSettings`.

### NamingRules

Each key under `NamingRules` matches a Step 1.2 category. The object contains:

- `Pattern` – target file name template. Use `{Placeholder}` tokens; the script fills them from rule mappings or defaults. Special placeholders `{Date}`, `{ext}`, and `{Rank}` are auto-populated when present.
- `Rules` – array of conditional overrides. Each rule defines:
  - `Condition` – supports the following keys:
    - `FileName` – regex evaluated against the original file name
    - `FullPath` – regex evaluated against the full path
    - `Keywords` – array of required keywords (case-insensitive, all must be present)
    - `Extension` – file extension match (e.g., `.csv` or `csv`)
  - `Mapping` – name/value pairs that populate placeholders in the pattern when the condition matches
- `DefaultMapping` – fallback values used when no rule matches; empty entries resolve to `Unknown`.

Categories in the classification data that are not listed in `NamingRules` are skipped with a warning.

### GlobalSettings

- `HandleDuplicates` – `AddVersion` (default) appends `_v2`, `_v3`, etc. when two files map to the same destination. `AppendRank` adds `_rank<Rank>` instead. Any other value leaves conflicts unresolved for manual review.
- `DateFormat` – applied to any `{Date}` placeholder when a rule does not supply `Date` explicitly.
- `PreservePaths` – when `true`, proposed names stay in the source directory; when `false`, paths are reassigned to the script directory while keeping the same file names.
- `BackupOriginals` – reserved for later steps (reported in the output for completeness).

## Output

Running the script produces three things:

- Console log listing every processed category, each file’s proposed name, and any conflicts that were auto-resolved.
- `rename_mappings.json` with:
  - Timestamp, summary stats, and the config path used
  - Full rename mapping objects (`OldPath`, `NewPath`, category, rule mapping, pattern, etc.)
  - Flags indicating whether the run was preview-only
- Exit status suitable for automation (non-zero when required inputs are missing or config parsing fails).

## Customization Workflow

1. Copy `naming_convention_config.json` to a safe location and adjust one category at a time.
2. Add or tweak rule `Condition` blocks to capture specific naming clues (regexes can stack with keyword checks).
3. Update `Pattern` placeholders and `DefaultMapping` values to match your preferred naming scheme.
4. Re-run the script with `-PreviewOnly` to inspect the proposed names and conflict handling.
5. Iterate until the mappings look right, then hand off `rename_mappings.json` to Step 1.4 to generate an executable rename plan.

Tip: Keep placeholders descriptive but concise (e.g., `{Topic}`, `{Context}`) and normalize values in the config (use underscores where spaces are undesirable).

## Troubleshooting

- **Missing inputs** – ensure both the classification results and naming config exist, or pass explicit paths.
- **Config errors** – the script reports invalid JSON or unsupported conditions with line-level context; fix the config and rerun.
- **Unexpected file names** – expand your rule set or adjust defaults; you can inspect individual `Mapping` objects inside `rename_mappings.json` to see which values were applied.
- **Persistent conflicts** – switch `HandleDuplicates` to a different strategy or refine the rules to diverge the generated names.

## Next Step

Feed `rename_mappings.json` into Step 1.4 to build the batch rename script once you are happy with the proposed conventions.
